[{"categories":null,"content":"概述 在runc的start命令代码如下： switch status { // 对于一个已经处于Created状态的容器，执行Exec case libcontainer.Created: return container.Exec() case libcontainer.Stopped: return errors.New(\"cannot start a container that has stopped\") case libcontainer.Running: return errors.New(\"cannot start an already running container\") default: return fmt.Errorf(\"cannot start a container in the %s state\\n\", status) } 说明已经 Stopped 的容器runc是不支持重新启动的。 但是在 docker，或这nerdctl 中，都存在 restart 命令。 解析来以 nerdctl 为例，看一下restart命令的实现。 if err := stopContainer(ctx, found.Container, timeout); err != nil { return err } if err := startContainer(ctx, found.Container, false, client); err != nil { return err } func startContainer(ctx context.Context, container containerd.Container, flagA bool, client *containerd.Client) error { ... ... if oldTask, err := container.Task(ctx, nil); err == nil { if _, err := oldTask.Delete(ctx); err != nil { logrus.WithError(err).Debug(\"failed to delete old task\") } } task, err := container.NewTask(ctx, taskCIO) if err != nil { return err } ... ... if err := task.Start(ctx); err != nil { return err } ... ... } 先oldTask.Delete，然后NewTask。 ","date":"2022-11-13","objectID":"/2022-11-13-containerd-6-restart/:1:0","tags":null,"title":"Containerd解析(6) - restart","uri":"/2022-11-13-containerd-6-restart/"},{"categories":null,"content":"oldTask.Delete nerdctl -\u003e containerd -\u003e shim 通过runc删除容器 err := p.runtime.Delete(ctx, p.id, nil) runc delete 取消rootfs挂载 if err2 := mount.UnmountAll(p.Rootfs, 0); err2 != nil { log.G(ctx).WithError(err2).Warn(\"failed to cleanup rootfs mount\") if err == nil { err = fmt.Errorf(\"failed rootfs umount: %w\", err2) } } 接下来通过 NewTask 重新创建容器，Start 启动容器，完成了容器的restart过程。 ","date":"2022-11-13","objectID":"/2022-11-13-containerd-6-restart/:2:0","tags":null,"title":"Containerd解析(6) - restart","uri":"/2022-11-13-containerd-6-restart/"},{"categories":null,"content":"总结 从runc的角度来看，restart 过程是删除了容器，再重新创建了一个同名容器。 ","date":"2022-11-13","objectID":"/2022-11-13-containerd-6-restart/:3:0","tags":null,"title":"Containerd解析(6) - restart","uri":"/2022-11-13-containerd-6-restart/"},{"categories":null,"content":"概述 本文只讨论containerd默认配置下的行为，不涉及docker。 参考：content-flow.md 执行 client.Pull(ctx, \"docker.io/library/redis:5.0.9\", containerd.WithPullUnpack)之后， containerd获取的内容如下(已排序)： /var/lib/containerd/io.containerd.content.v1.content/blobs └── sha256 ├── 2a9865e55c37293b71df051922022898d8e4ec0f579c9b53a0caee1b170bc81c - the index ├── 9bb13890319dc01e5f8a4d3d0c4c72685654d682d568350fd38a02b1d70aee6b - the manifest for linux/amd64 ├── 987b553c835f01f46eb1859bc32f564119d5833801a27b25a0ca5c6b8b6e111a - the config ├── bb79b6b2107fea8e8a47133a660b78e3a546998fcf0427be39ac9a0af4a97e90 - layer 0 ├── 1ed3521a5dcbd05214eb7f35b952ecf018d5a6610c32ba4e315028c556f45e94 - layer 1 ├── 5999b99cee8f2875d391d64df20b6296b63f23951a7d41749f028375e887cd05 - layer 2 ├── bfee6cb5fdad6b60ec46297f44542ee9d8ac8f01c072313a51cd7822df3b576f - layer 3 ├── fd36a1ebc6728807cbb1aa7ef24a1861343c6dc174657721c496613c7b53bd07 - layer 4 └── 97481c7992ebf6f22636f87e4d7b79e962f928cdbe6f2337670fa6c9a9636f04 - layer 5 ➜ ~ ctr content ls（已整理排序） the index: sha256:2a9865e55c37293b71df051922022898d8e4ec0f579c9b53a0caee1b170bc81c containerd.io/gc.ref.content.m.4=sha256:ee0e1f8d8d338c9506b0e487ce6c2c41f931d1e130acd60dc7794c3a246eb59e, containerd.io/gc.ref.content.m.3=sha256:613f4797d2b6653634291a990f3e32378c7cfe3cdd439567b26ca340b8946013, containerd.io/gc.ref.content.m.0=sha256:9bb13890319dc01e5f8a4d3d0c4c72685654d682d568350fd38a02b1d70aee6b, containerd.io/gc.ref.content.m.1=sha256:aeb53f8db8c94d2cd63ca860d635af4307967aa11a2fdead98ae0ab3a329f470, containerd.io/gc.ref.content.m.6=sha256:4b7860fcaea5b9bbd6249c10a3dc02a5b9fb339e8aef17a542d6126a6af84d96, containerd.io/gc.ref.content.m.7=sha256:d66dfc869b619cd6da5b5ae9d7b1cbab44c134b31d458de07f7d580a84b63f69, containerd.io/gc.ref.content.m.5=sha256:1072145f8eea186dcedb6b377b9969d121a00e65ae6c20e9cd631483178ea7ed, containerd.io/gc.ref.content.m.2=sha256:17dc42e40d4af0a9e84c738313109f3a95e598081beef6c18a05abb57337aa5d, containerd.io/distribution.source.docker.io=library/redis, the manifest for linux/amd64 sha256:9bb13890319dc01e5f8a4d3d0c4c72685654d682d568350fd38a02b1d70aee6b containerd.io/gc.ref.content.config=sha256:987b553c835f01f46eb1859bc32f564119d5833801a27b25a0ca5c6b8b6e111a, containerd.io/gc.ref.content.l.0=sha256:bb79b6b2107fea8e8a47133a660b78e3a546998fcf0427be39ac9a0af4a97e90, containerd.io/gc.ref.content.l.1=sha256:1ed3521a5dcbd05214eb7f35b952ecf018d5a6610c32ba4e315028c556f45e94, containerd.io/gc.ref.content.l.2=sha256:5999b99cee8f2875d391d64df20b6296b63f23951a7d41749f028375e887cd05, containerd.io/gc.ref.content.l.3=sha256:bfee6cb5fdad6b60ec46297f44542ee9d8ac8f01c072313a51cd7822df3b576f, containerd.io/gc.ref.content.l.4=sha256:fd36a1ebc6728807cbb1aa7ef24a1861343c6dc174657721c496613c7b53bd07, containerd.io/gc.ref.content.l.5=sha256:97481c7992ebf6f22636f87e4d7b79e962f928cdbe6f2337670fa6c9a9636f04, containerd.io/distribution.source.docker.io=library/redis the config sha256:987b553c835f01f46eb1859bc32f564119d5833801a27b25a0ca5c6b8b6e111a containerd.io/gc.ref.snapshot.overlayfs=sha256:33bd296ab7f37bdacff0cb4a5eb671bcb3a141887553ec4157b1e64d6641c1cd, containerd.io/distribution.source.docker.io=library/redis sha256:bb79b6b2107fea8e8a47133a660b78e3a546998fcf0427be39ac9a0af4a97e90 containerd.io/uncompressed=sha256:d0fe97fa8b8cefdffcef1d62b65aba51a6c87b6679628a2b50fc6a7a579f764c sha256:1ed3521a5dcbd05214eb7f35b952ecf018d5a6610c32ba4e315028c556f45e94 containerd.io/uncompressed=sha256:832f21763c8e6b070314e619ebb9ba62f815580da6d0eaec8a1b080bd01575f7 sha256:5999b99cee8f2875d391d64df20b6296b63f23951a7d41749f028375e887cd05 containerd.io/uncompressed=sha256:223b15010c47044b6bab9611c7a322e8da7660a8268949e18edde9c6e3ea3700 sha256:bfee6cb5fdad6b60ec46297f44542ee9d8ac8f01c072313a51cd7822df3b576f containerd.io/uncompressed=sha256:b96fedf8ee00e59bf69cf5bc8ed19e92e66ee8cf83f0174e33127402b650331d sha256:fd36a1ebc6728807cbb1aa7ef24a1861343c6dc174657721c496613c7b53bd07 containerd.io/uncompressed=sha256:aff00695be0cebb8a114f8c5187fd6dd3d806273004797a00ad934ec9cd98212 ","date":"2022-11-02","objectID":"/2022-11-02-containerd-2-layer/:1:0","tags":null,"title":"Containerd解析(2) - layer","uri":"/2022-11-02-containerd-2-layer/"},{"categories":null,"content":"通过 diff_ids 找到 Final Layer Final Layer 也可以通过 config 配置文件中的 diff_ids 数组求出来 \"diff_ids\": [ \"sha256:d0fe97fa8b8cefdffcef1d62b65aba51a6c87b6679628a2b50fc6a7a579f764c\", \"sha256:832f21763c8e6b070314e619ebb9ba62f815580da6d0eaec8a1b080bd01575f7\", \"sha256:223b15010c47044b6bab9611c7a322e8da7660a8268949e18edde9c6e3ea3700\", \"sha256:b96fedf8ee00e59bf69cf5bc8ed19e92e66ee8cf83f0174e33127402b650331d\", \"sha256:aff00695be0cebb8a114f8c5187fd6dd3d806273004797a00ad934ec9cd98212\", \"sha256:d442ae63d423b4b1922875c14c3fa4e801c66c689b69bfd853758fde996feffb\" ] func TestFinalLayer(t *testing.T) { diffIDs := []digest.Digest{ \"sha256:d0fe97fa8b8cefdffcef1d62b65aba51a6c87b6679628a2b50fc6a7a579f764c\", \"sha256:832f21763c8e6b070314e619ebb9ba62f815580da6d0eaec8a1b080bd01575f7\", \"sha256:223b15010c47044b6bab9611c7a322e8da7660a8268949e18edde9c6e3ea3700\", \"sha256:b96fedf8ee00e59bf69cf5bc8ed19e92e66ee8cf83f0174e33127402b650331d\", \"sha256:aff00695be0cebb8a114f8c5187fd6dd3d806273004797a00ad934ec9cd98212\", \"sha256:d442ae63d423b4b1922875c14c3fa4e801c66c689b69bfd853758fde996feffb\"} finalLayer := identity.ChainID(diffIDs).String() fmt.Println(finalLayer) } === RUN TestFinalLayer sha256:33bd296ab7f37bdacff0cb4a5eb671bcb3a141887553ec4157b1e64d6641c1cd --- PASS: TestFinalLayer (0.00s) PASS 创建容器的时候，需要可读写层。这个可读写层的parent就是这里提到的Final Layer ","date":"2022-11-02","objectID":"/2022-11-02-containerd-2-layer/:2:0","tags":null,"title":"Containerd解析(2) - layer","uri":"/2022-11-02-containerd-2-layer/"},{"categories":null,"content":"diff_ids // TODO config 配置文件中的 diff_ids 数组是如何生成的？ ","date":"2022-11-02","objectID":"/2022-11-02-containerd-2-layer/:3:0","tags":null,"title":"Containerd解析(2) - layer","uri":"/2022-11-02-containerd-2-layer/"},{"categories":null,"content":"概述 本文使用containerd默认配置，不涉及docker。 通过一个简单的例子，粗略了解containerd创建并运行一个容器的过程。 主要了解containerd怎样与containerd-shim-runc-v2进行交互，以及containerd-shim-runc-v2怎样调用runc与监控容器。 代码版本： 1c90a442489720eec95342e1789ee8a5e1b9536f ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:1:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"Example 使用官方的例子，对containerd，containerd-shim-runc-v2 的代码进行debug package main import ( \"context\" \"fmt\" \"log\" \"syscall\" \"time\" \"github.com/containerd/containerd\" \"github.com/containerd/containerd/cio\" \"github.com/containerd/containerd/oci\" \"github.com/containerd/containerd/namespaces\" ) func main() { if err := redisExample(); err != nil { log.Fatal(err) } } func redisExample() error { // create a new client connected to the default socket path for containerd client, err := containerd.New(\"/run/containerd/containerd.sock\") if err != nil { return err } defer client.Close() // create a new context with an \"example\" namespace // 这里将 example 改为 ctx := namespaces.WithNamespace(context.Background(), \"default\") // pull the redis image from DockerHub image, err := client.Pull(ctx, \"docker.io/library/redis:alpine\", containerd.WithPullUnpack) if err != nil { return err } // create a container container, err := client.NewContainer( ctx, \"redis-server\", containerd.WithImage(image), containerd.WithNewSnapshot(\"redis-server-snapshot\", image), containerd.WithNewSpec(oci.WithImageConfig(image)), ) if err != nil { return err } defer container.Delete(ctx, containerd.WithSnapshotCleanup) // create a task from the container task, err := container.NewTask(ctx, cio.NewCreator(cio.WithStdio)) if err != nil { return err } defer task.Delete(ctx) // make sure we wait before calling start exitStatusC, err := task.Wait(ctx) if err != nil { fmt.Println(err) } // call start on the task to execute the redis server if err := task.Start(ctx); err != nil { return err } // sleep for a lil bit to see the logs time.Sleep(3 * time.Second) // kill the process and get the exit status if err := task.Kill(ctx, syscall.SIGTERM); err != nil { return err } // wait for the process to fully exit and print out the exit status status := \u003c-exitStatusC code, _, err := status.Result() if err != nil { return err } fmt.Printf(\"redis-server exited with status: %d\\n\", code) return nil } ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:2:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"[client] client.Pull() // pull the redis image from DockerHub image, err := client.Pull(ctx,\"docker.io/library/redis:alpine\",containerd.WithPullUnpack) if err != nil { return err } containerd启动时，初始文件夹如下 /var/lib/containerd/ ├── io.containerd.content.v1.content │ └── ingest ├── io.containerd.metadata.v1.bolt │ └── meta.db ├── io.containerd.runtime.v1.linux ├── io.containerd.runtime.v2.task ├── io.containerd.snapshotter.v1.aufs │ └── snapshots ├── io.containerd.snapshotter.v1.btrfs ├── io.containerd.snapshotter.v1.native │ └── snapshots ├── io.containerd.snapshotter.v1.overlayfs │ └── snapshots └── tmpmounts /run/containerd/ ├── containerd.sock ├── containerd.sock.ttrpc ├── io.containerd.runtime.v1.linux └── io.containerd.runtime.v2.tas // Pull downloads the provided content into containerd's content store // and returns a platform specific image object func (c *Client) Pull(ctx context.Context, ref string, opts ...RemoteOpt) (_ Image, retErr error) { pullCtx := defaultRemoteContext() for _, o := range opts { if err := o(c, pullCtx); err != nil { return nil, err } } if pullCtx.PlatformMatcher == nil { if len(pullCtx.Platforms) \u003e 1 { return nil, errors.New(\"cannot pull multiplatform image locally, try Fetch\") } else if len(pullCtx.Platforms) == 0 { pullCtx.PlatformMatcher = c.platform // MatchComparer 能够匹配和比较平台以过滤和排序平台。 } else { p, err := platforms.Parse(pullCtx.Platforms[0]) if err != nil { return nil, fmt.Errorf(\"invalid platform %s: %w\", pullCtx.Platforms[0], err) } pullCtx.PlatformMatcher = platforms.Only(p) } } ctx, done, err := c.WithLease(ctx) if err != nil { return nil, err } defer done(ctx) var unpacks int32 var unpackEg *errgroup.Group var unpackWrapper func(f images.Handler) images.Handler if pullCtx.Unpack { // unpacker only supports schema 2 image, for schema 1 this is noop. u, err := c.newUnpacker(ctx, pullCtx) if err != nil { return nil, fmt.Errorf(\"create unpacker: %w\", err) } unpackWrapper, unpackEg = u.handlerWrapper(ctx, pullCtx, \u0026unpacks) defer func() { if err := unpackEg.Wait(); err != nil { if retErr == nil { retErr = fmt.Errorf(\"unpack: %w\", err) } } }() wrapper := pullCtx.HandlerWrapper pullCtx.HandlerWrapper = func(h images.Handler) images.Handler { if wrapper == nil { return unpackWrapper(h) } return unpackWrapper(wrapper(h)) } } // 获取镜像的主要逻辑都在 fetch 方法 img, err := c.fetch(ctx, pullCtx, ref, 1) if err != nil { return nil, err } // NOTE(fuweid): unpacker defers blobs download. before create image // record in ImageService, should wait for unpacking(including blobs // download). if pullCtx.Unpack { if unpackEg != nil { // 等待镜像相关文件下载完成 if err := unpackEg.Wait(); err != nil { return nil, err } } } // 调用containerd接口，往 /var/lib/containerd/io.containerd.metadata.v1.bolt/meta.db // 数据库写入一个 images img, err = c.createNewImage(ctx, img) if err != nil { return nil, err } i := NewImageWithPlatform(c, img, pullCtx.PlatformMatcher) if pullCtx.Unpack { if unpacks == 0 { // Try to unpack is none is done previously. // This is at least required for schema 1 image. if err := i.Unpack(ctx, pullCtx.Snapshotter, pullCtx.UnpackOpts...); err != nil { return nil, fmt.Errorf(\"failed to unpack image on snapshotter %s: %w\", pullCtx.Snapshotter, err) } } } return i, nil } 查看fetch方法： func (c *Client) fetch(ctx context.Context, rCtx *RemoteContext, ref string, limit int) (images.Image, error) { store := c.ContentStore() // 通过 https://registry-1.docker.io/v2/library/redis/manifests/5.0.9 获取 Digest // 内容大致如下：sha256:2a9865e55c37293b71df051922022898d8e4ec0f579c9b53a0caee1b170bc81c name, desc, err := rCtx.Resolver.Resolve(ctx, ref) if err != nil { return images.Image{}, fmt.Errorf(\"failed to resolve reference %q: %w\", ref, err) } fetcher, err := rCtx.Resolver.Fetcher(ctx, name) if err != nil { return images.Image{}, fmt.Errorf(\"failed to get fetcher for %q: %w\", name, err) } var ( handler images.Handler isConvertible bool converterFunc func(context.Context, ocispec.Descriptor) (ocispec.Descriptor, error) limiter *semaphore.Weighted ) if de","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:3:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"[client] client.NewContainer() NewContainer()方法如下： // NewContainer will create a new container with the provided id. // The id must be unique within the namespace. func (c *Client) NewContainer(ctx context.Context, id string, opts ...NewContainerOpts) (Container, error) { ctx, done, err := c.WithLease(ctx) if err != nil { return nil, err } defer done(ctx) container := containers.Container{ ID: id, Runtime: containers.RuntimeInfo{ Name: c.runtime, }, } for _, o := range opts { if err := o(ctx, c, \u0026container); err != nil { return nil, err } } r, err := c.ContainerService().Create(ctx, container) if err != nil { return nil, err } return containerFromRecord(c, r), nil } 查看前面传入的参数： \"redis-server\", containerd.WithImage(image), containerd.WithNewSnapshot(\"redis-server-snapshot\", image), containerd.WithNewSpec(oci.WithImageConfig(image)), iredis-server为容器id，其他三个为初始化选项。 ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:4:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"WithImage： // WithImage sets the provided image as the base for the container // 将提供的图像设置为容器的基础 func WithImage(i Image) NewContainerOpts { return func(ctx context.Context, client *Client, c *containers.Container) error { c.Image = i.Name() return nil } } ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:4:1","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"WithNewSpec： // WithNewSpec generates a new spec for a new container // 为新容器生成新规范 func WithNewSpec(opts ...oci.SpecOpts) NewContainerOpts { return func(ctx context.Context, client *Client, c *containers.Container) error { s, err := oci.GenerateSpec(ctx, client, c, opts...) if err != nil { return err } c.Spec, err = typeurl.MarshalAny(s) return err } } ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:4:2","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"WithNewSnapshot: // WithNewSnapshot allocates a new snapshot to be used by the container as the // root filesystem in read-write mode // 分配一个新的快照供容器用作读写模式下的根文件系统 func WithNewSnapshot(id string, i Image, opts ...snapshots.Opt) NewContainerOpts { return func(ctx context.Context, client *Client, c *containers.Container) error { // 从 meta.db 中拿到config，从而拿到diffIDs diffIDs, err := i.RootFS(ctx) if err != nil { return err } // 根据 diffIDs 获取 ChainIDs // 进而获取 parent（即镜像的finalLayer，作为可读写层的parent） parent := identity.ChainID(diffIDs).String() c.Snapshotter, err = client.resolveSnapshotterName(ctx, c.Snapshotter) if err != nil { return err } s, err := client.getSnapshotter(ctx, c.Snapshotter) if err != nil { return err } // Prepare if _, err := s.Prepare(ctx, id, parent, opts...); err != nil { return err } c.SnapshotKey = id c.Image = i.Name() return nil } } func (p *proxySnapshotter) Prepare(ctx context.Context, key, parent string, opts ...snapshots.Opt) ([]mount.Mount, error) { var local snapshots.Info for _, opt := range opts { if err := opt(\u0026local); err != nil { return nil, err } } // 调用 containerd 的 snapshots.Prepare()接口 resp, err := p.client.Prepare(ctx, \u0026snapshotsapi.PrepareSnapshotRequest{ Snapshotter: p.snapshotterName, Key: key, Parent: parent, Labels: local.Labels, }) if err != nil { return nil, errdefs.FromGRPC(err) } return toMounts(resp.Mounts), nil } [containerd] client.Prepare() /containerd/services/snapshots/service.go L88 func (s *service) Prepare(ctx context.Context, pr *snapshotsapi.PrepareSnapshotRequest) (*snapshotsapi.PrepareSnapshotResponse, error) { log.G(ctx).WithField(\"parent\", pr.Parent).WithField(\"key\", pr.Key).Debugf(\"prepare snapshot\") sn, err := s.getSnapshotter(pr.Snapshotter) if err != nil { return nil, err } var opts []snapshots.Opt if pr.Labels != nil { opts = append(opts, snapshot.WithLabels(pr.Labels)) } // 创建 snapshot mounts, err := sn.Prepare(ctx, pr.Key, pr.Parent, opts...) if err != nil { return nil, errdefs.ToGRPC(err) } return \u0026snapshotsapi.PrepareSnapshotResponse{ Mounts: fromMounts(mounts), }, nil } func (s *snapshotter) Prepare(ctx context.Context, key, parent string, opts ...snapshots.Opt) ([]mount.Mount, error) { // 创建可读写层并入库 mounts, err := s.Snapshotter.Prepare(ctx, key, parent, opts...) if err != nil { return nil, err } // 发送event？这部分内容待补充 if err := s.publisher.Publish(ctx, \"/snapshot/prepare\", \u0026eventstypes.SnapshotPrepare{ Key: key, Parent: parent, Snapshotter: s.name, }); err != nil { return nil, err } return mounts, nil } Prepare方法执行完后，新增了一个Snapshot，如下： ➜ ~ ctr snapshot ls [sudo] password for xiu: KEY PARENT KIND redis-server-snapshot sha256:33bd296ab7f37bdacff0cb4a5eb671bcb3a141887553ec4157b1e64d6641c1cd Active sha256:2ae5fa95c0fce5ef33fbb87a7e2f49f2a56064566a37a83b97d3f668c10b43d6 sha256:d0fe97fa8b8cefdffcef1d62b65aba51a6c87b6679628a2b50fc6a7a579f764c Committed sha256:33bd296ab7f37bdacff0cb4a5eb671bcb3a141887553ec4157b1e64d6641c1cd sha256:bc8b010e53c5f20023bd549d082c74ef8bfc237dc9bbccea2e0552e52bc5fcb1 Committed sha256:a8f09c4919857128b1466cc26381de0f9d39a94171534f63859a662d50c396ca sha256:2ae5fa95c0fce5ef33fbb87a7e2f49f2a56064566a37a83b97d3f668c10b43d6 Committed sha256:aa4b58e6ece416031ce00869c5bf4b11da800a397e250de47ae398aea2782294 sha256:a8f09c4919857128b1466cc26381de0f9d39a94171534f63859a662d50c396ca Committed sha256:bc8b010e53c5f20023bd549d082c74ef8bfc237dc9bbccea2e0552e52bc5fcb1 sha256:aa4b58e6ece416031ce00869c5bf4b11da800a397e250de47ae398aea2782294 Committed sha256:d0fe97fa8b8cefdffcef1d62b65aba51a6c87b6679628a2b50fc6a7a579f764c Committed 可以看到该snapshot的key是我们传进的参数redis-server-snapshot，parent是刚才提到的镜像的final layer：33bd296ab7f37bdacff0cb4a5eb671bcb3a141887553ec4157b1e64d6641c1cd。 ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:4:3","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"[containerd] c.ContainerService().Create() 接下来进入create流程，直接调用containerd的create接口。 containerd/services/containers/local.go L116 func (l *local) Create(ctx context.Context, req *api.CreateContainerRequest, _ ...grpc.CallOption) (*api.CreateContainerResponse, error) { var resp api.CreateContainerResponse if err := l.withStoreUpdate(ctx, func(ctx context.Context) error { container := containerFromProto(req.Container) created, err := l.Store.Create(ctx, container) if err != nil { return err } resp.Container = containerToProto(\u0026created) return nil }); err != nil { return \u0026resp, errdefs.ToGRPC(err) } // 发送event？这部分内容待补充 if err := l.publisher.Publish(ctx, \"/containers/create\", \u0026eventstypes.ContainerCreate{ ID: resp.Container.ID, Image: resp.Container.Image, Runtime: \u0026eventstypes.ContainerCreate_Runtime{ Name: resp.Container.Runtime.Name, Options: resp.Container.Runtime.Options, }, }); err != nil { return \u0026resp, err } return \u0026resp, nil } container参数内容如下： 入库的内容如下： 使用 nerdctl查看，如下： ➜ ~ sudo nerdctl ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES redis-server docker.io/library/redis:5.0.9 \"docker-entrypoint.s…\" 8 minutes ago Created 由上面分析可知，create操作只在数据库中插入了一条数据。 ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:4:4","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"[client] container.NewTask() func (c *container) NewTask(ctx context.Context, ioCreate cio.Creator, opts ...NewTaskOpts) (_ Task, err error) { i, err := ioCreate(c.id) if err != nil { return nil, err } defer func() { if err != nil \u0026\u0026 i != nil { i.Cancel() i.Close() } }() // 配置三个std // Stdin=/run/containerd/fifo/908671294/redis-server-stdin // Stdout=/run/containerd/fifo/908671294/redis-server-stdout // Stderr=/run/containerd/fifo/908671294/redis-server-stderr cfg := i.Config() request := \u0026tasks.CreateTaskRequest{ ContainerID: c.id, Terminal: cfg.Terminal, Stdin: cfg.Stdin, Stdout: cfg.Stdout, Stderr: cfg.Stderr, } r, err := c.get(ctx) if err != nil { return nil, err } if r.SnapshotKey != \"\" { if r.Snapshotter == \"\" { return nil, fmt.Errorf(\"unable to resolve rootfs mounts without snapshotter on container: %w\", errdefs.ErrInvalidArgument) } // get the rootfs from the snapshotter and add it to the request s, err := c.client.getSnapshotter(ctx, r.Snapshotter) if err != nil { return nil, err } // Options[0]: index=off // Options[1]: workdir=/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/7/work // Options[2]: upperdir=/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/7/fs // Options[3]: lowerdir=/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/6/fs:/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/5/fs:/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/4/fs:/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/3/fs:/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/2/fs:/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/1/fs mounts, err := s.Mounts(ctx, r.SnapshotKey) if err != nil { return nil, err } spec, err := c.Spec(ctx) if err != nil { return nil, err } for _, m := range mounts { if spec.Linux != nil \u0026\u0026 spec.Linux.MountLabel != \"\" { context := label.FormatMountLabel(\"\", spec.Linux.MountLabel) if context != \"\" { m.Options = append(m.Options, context) } } request.Rootfs = append(request.Rootfs, \u0026types.Mount{ Type: m.Type, Source: m.Source, Options: m.Options, }) } } info := TaskInfo{ runtime: r.Runtime.Name, } for _, o := range opts { if err := o(ctx, c.client, \u0026info); err != nil { return nil, err } } if info.RootFS != nil { for _, m := range info.RootFS { request.Rootfs = append(request.Rootfs, \u0026types.Mount{ Type: m.Type, Source: m.Source, Options: m.Options, }) } } if info.Options != nil { any, err := typeurl.MarshalAny(info.Options) if err != nil { return nil, err } request.Options = any } t := \u0026task{ client: c.client, io: i, id: c.id, c: c, } if info.Checkpoint != nil { request.Checkpoint = info.Checkpoint } // response, err := c.client.TaskService().Create(ctx, request) if err != nil { return nil, errdefs.FromGRPC(err) } t.pid = response.Pid return t, nil } 最终组成的request请求参数如下： task request 调用containerd TaskService().Create()接口。 ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:5:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"[containerd] (l *local) Create() containerd/services/tasks/local.go L164 func (l *local) Create(ctx context.Context, r *api.CreateTaskRequest, _ ...grpc.CallOption) (*api.CreateTaskResponse, error) { container, err := l.getContainer(ctx, r.ContainerID) if err != nil { return nil, errdefs.ToGRPC(err) } checkpointPath, err := getRestorePath(container.Runtime.Name, r.Options) if err != nil { return nil, err } // jump get checkpointPath from checkpoint image if checkpointPath == \"\" \u0026\u0026 r.Checkpoint != nil { checkpointPath, err = os.MkdirTemp(os.Getenv(\"XDG_RUNTIME_DIR\"), \"ctrd-checkpoint\") if err != nil { return nil, err } if r.Checkpoint.MediaType != images.MediaTypeContainerd1Checkpoint { return nil, fmt.Errorf(\"unsupported checkpoint type %q\", r.Checkpoint.MediaType) } reader, err := l.store.ReaderAt(ctx, ocispec.Descriptor{ MediaType: r.Checkpoint.MediaType, Digest: digest.Digest(r.Checkpoint.Digest), Size: r.Checkpoint.Size, Annotations: r.Checkpoint.Annotations, }) if err != nil { return nil, err } _, err = archive.Apply(ctx, checkpointPath, content.NewReader(reader)) reader.Close() if err != nil { return nil, err } } opts := runtime.CreateOpts{ Spec: container.Spec, IO: runtime.IO{ Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, }, Checkpoint: checkpointPath, Runtime: container.Runtime.Name, RuntimeOptions: container.Runtime.Options, TaskOptions: r.Options, SandboxID: container.SandboxID, } if r.RuntimePath != \"\" { opts.Runtime = r.RuntimePath } for _, m := range r.Rootfs { opts.Rootfs = append(opts.Rootfs, mount.Mount{ Type: m.Type, Source: m.Source, Options: m.Options, }) } if strings.HasPrefix(container.Runtime.Name, \"io.containerd.runtime.v1.\") { log.G(ctx).Warn(\"runtime v1 is deprecated since containerd v1.4, consider using runtime v2\") } else if container.Runtime.Name == plugin.RuntimeRuncV1 { log.G(ctx).Warnf(\"%q is deprecated since containerd v1.4, consider using %q\", plugin.RuntimeRuncV1, plugin.RuntimeRuncV2) } rtime, err := l.getRuntime(container.Runtime.Name) if err != nil { return nil, err } _, err = rtime.Get(ctx, r.ContainerID) if err != nil \u0026\u0026 !errdefs.IsNotFound(err) { return nil, errdefs.ToGRPC(err) } if err == nil { return nil, errdefs.ToGRPC(fmt.Errorf(\"task %s: %w\", r.ContainerID, errdefs.ErrAlreadyExists)) } // Create 启动新的 shim 实例并创建新任务 c, err := rtime.Create(ctx, r.ContainerID, opts) if err != nil { return nil, errdefs.ToGRPC(err) } labels := map[string]string{\"runtime\": container.Runtime.Name} if err := l.monitor.Monitor(c, labels); err != nil { return nil, fmt.Errorf(\"monitor task: %w\", err) } pid, err := c.PID(ctx) if err != nil { return nil, fmt.Errorf(\"failed to get task pid: %w\", err) } return \u0026api.CreateTaskResponse{ ContainerID: r.ContainerID, Pid: pid, }, nil } rtime.Create() rtime.Create(ctx, r.ContainerID, opts)是个比较重要的方法，终于看到和 shim 相关的内容了 // Create launches new shim instance and creates new task func (m *TaskManager) Create(ctx context.Context, taskID string, opts runtime.CreateOpts) (runtime.Task, error) { // 1 shim, err := m.manager.Start(ctx, taskID, opts) if err != nil { return nil, fmt.Errorf(\"failed to start shim: %w\", err) } // Cast to shim task and call task service to create a new container task instance. // This will not be required once shim service / client implemented. shimTask := newShimTask(shim) // 2 t, err := shimTask.Create(ctx, opts) if err != nil { // NOTE: ctx contains required namespace information. m.manager.shims.Delete(ctx, taskID) dctx, cancel := timeout.WithContext(context.Background(), cleanupTimeout) defer cancel() sandboxed := opts.SandboxID != \"\" _, errShim := shimTask.delete(dctx, sandboxed, func(context.Context, string) {}) if errShim != nil { if errdefs.IsDeadlineExceeded(errShim) { dctx, cancel = timeout.WithContext(context.Background(), cleanupTimeout) defer cancel() } shimTask.Shutdown(dctx) shimTask.Client().Close() } return nil, fmt.Errorf(\"failed to create shim task: %w\", err) } return t, nil } m.manager.Start() // Start launc","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:5:1","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"[containerd-shim-runc-v2] Create() containerd/runtime/v2/runc/task/service.go L118 // Create a new initial process and container with the underlying OCI runtime func (s *service) Create(ctx context.Context, r *taskAPI.CreateTaskRequest) (_ *taskAPI.CreateTaskResponse, err error) { s.mu.Lock() defer s.mu.Unlock() container, err := runc.NewContainer(ctx, s.platform, r) if err != nil { return nil, err } s.containers[r.ID] = container s.send(\u0026eventstypes.TaskCreate{ ContainerID: r.ID, Bundle: r.Bundle, Rootfs: r.Rootfs, IO: \u0026eventstypes.TaskIO{ Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Terminal: r.Terminal, }, Checkpoint: r.Checkpoint, Pid: uint32(container.Pid()), }) return \u0026taskAPI.CreateTaskResponse{ Pid: uint32(container.Pid()), }, nil } ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:6:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"runc.NewContainer(ctx, s.platform, r) // NewContainer returns a new runc container func NewContainer(ctx context.Context, platform stdio.Platform, r *task.CreateTaskRequest) (_ *Container, retErr error) { ns, err := namespaces.NamespaceRequired(ctx) if err != nil { return nil, fmt.Errorf(\"create namespace: %w\", err) } opts := \u0026options.Options{} if r.Options.GetValue() != nil { v, err := typeurl.UnmarshalAny(r.Options) if err != nil { return nil, err } if v != nil { opts = v.(*options.Options) } } var mounts []process.Mount for _, m := range r.Rootfs { mounts = append(mounts, process.Mount{ Type: m.Type, Source: m.Source, Target: m.Target, Options: m.Options, }) } rootfs := \"\" if len(mounts) \u003e 0 { rootfs = filepath.Join(r.Bundle, \"rootfs\") if err := os.Mkdir(rootfs, 0711); err != nil \u0026\u0026 !os.IsExist(err) { return nil, err } } config := \u0026process.CreateConfig{ ID: r.ID, Bundle: r.Bundle, Runtime: opts.BinaryName, Rootfs: mounts, Terminal: r.Terminal, Stdin: r.Stdin, Stdout: r.Stdout, Stderr: r.Stderr, Checkpoint: r.Checkpoint, ParentCheckpoint: r.ParentCheckpoint, Options: r.Options, } if err := WriteOptions(r.Bundle, opts); err != nil { return nil, err } // For historical reason, we write opts.BinaryName as well as the entire opts if err := WriteRuntime(r.Bundle, opts.BinaryName); err != nil { return nil, err } defer func() { if retErr != nil { if err := mount.UnmountAll(rootfs, 0); err != nil { logrus.WithError(err).Warn(\"failed to cleanup rootfs mount\") } } }() // 在这里进行rootfs的挂载 for _, rm := range mounts { m := \u0026mount.Mount{ Type: rm.Type, Source: rm.Source, Options: rm.Options, } if err := m.Mount(rootfs); err != nil { return nil, fmt.Errorf(\"failed to mount rootfs component %v: %w\", m, err) } } p, err := newInit( ctx, r.Bundle, filepath.Join(r.Bundle, \"work\"), ns, platform, config, opts, rootfs, ) if err != nil { return nil, errdefs.ToGRPC(err) } // 组装 p 和 config，准备调用runc if err := p.Create(ctx, config); err != nil { return nil, errdefs.ToGRPC(err) } container := \u0026Container{ ID: r.ID, Bundle: r.Bundle, process: p, processes: make(map[string]process.Process), reservedProcess: make(map[string]struct{}), } pid := p.Pid() if pid \u003e 0 { var cg interface{} if cgroups.Mode() == cgroups.Unified { g, err := cgroupsv2.PidGroupPath(pid) if err != nil { logrus.WithError(err).Errorf(\"loading cgroup2 for %d\", pid) return container, nil } cg, err = cgroupsv2.LoadManager(\"/sys/fs/cgroup\", g) if err != nil { logrus.WithError(err).Errorf(\"loading cgroup2 for %d\", pid) } } else { cg, err = cgroups.Load(cgroups.V1, cgroups.PidPath(pid)) if err != nil { logrus.WithError(err).Errorf(\"loading cgroup for %d\", pid) } } container.cgroup = cg } return container, nil } 在 p.Create(ctx, config)之前，有一个比较重要的操作，就是 m.Mount(rootfs) m.Mount(rootfs) for _, rm := range mounts { m := \u0026mount.Mount{ Type: rm.Type, Source: rm.Source, Options: rm.Options, } if err := m.Mount(rootfs); err != nil { return nil, fmt.Errorf(\"failed to mount rootfs component %v: %w\", m, err) } } m.Mount(rootfs)执行了挂载。 相关参数如下： m 其中，Options[3]的内容如下： lowerdir= /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/6/fs: /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/5/fs: /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/4/fs: /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/3/fs: /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/2/fs: /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/1/fs rootfs 执行完成后，/run/containerd/文件夹内容如下： p.Create(ctx, config) // Create the process with the provided config func (p *Init) Create(ctx context.Context, r *CreateConfig) error { var ( err error socket *runc.Socket pio *processIO pidFile = newPidFile(p.Bundle) ) if r.Terminal { if socket, err = runc.NewTempConsoleSocket(); err != nil { return fmt.Errorf(\"failed to create OCI runtime console socket: %w\", err) } defer socket.Close() } else { if pio, err = createIO(ctx, p.id, p.IoUID, p.IoGID, p.stdio); err","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:6:1","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"[client] task.Start(ctx) // call start on the task to execute the redis server if err := task.Start(ctx); err != nil { return err } ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:7:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"[containerd] (l *local) Start() func (l *local) Start(ctx context.Context, r *api.StartRequest, _ ...grpc.CallOption) (*api.StartResponse, error) { t, err := l.getTask(ctx, r.ContainerID) if err != nil { return nil, err } p := runtime.Process(t) if r.ExecID != \"\" { if p, err = t.Process(ctx, r.ExecID); err != nil { return nil, errdefs.ToGRPC(err) } } // containerd-shim-runc-v2 if err := p.Start(ctx); err != nil { return nil, errdefs.ToGRPC(err) } state, err := p.State(ctx) if err != nil { return nil, errdefs.ToGRPC(err) } return \u0026api.StartResponse{ Pid: state.Pid, }, nil } [containerd-shim-runc-v2] p.Start(ctx) // Start a process func (s *service) Start(ctx context.Context, r *taskAPI.StartRequest) (*taskAPI.StartResponse, error) { container, err := s.getContainer(r.ID) if err != nil { return nil, err } // hold the send lock so that the start events are sent before any exit events in the error case s.eventSendMu.Lock() // p, err := container.Start(ctx, r) if err != nil { s.eventSendMu.Unlock() return nil, errdefs.ToGRPC(err) } switch r.ExecID { case \"\": switch cg := container.Cgroup().(type) { case cgroups.Cgroup: if err := s.ep.Add(container.ID, cg); err != nil { logrus.WithError(err).Error(\"add cg to OOM monitor\") } case *cgroupsv2.Manager: allControllers, err := cg.RootControllers() if err != nil { logrus.WithError(err).Error(\"failed to get root controllers\") } else { if err := cg.ToggleControllers(allControllers, cgroupsv2.Enable); err != nil { if userns.RunningInUserNS() { logrus.WithError(err).Debugf(\"failed to enable controllers (%v)\", allControllers) } else { logrus.WithError(err).Errorf(\"failed to enable controllers (%v)\", allControllers) } } } if err := s.ep.Add(container.ID, cg); err != nil { logrus.WithError(err).Error(\"add cg to OOM monitor\") } } s.send(\u0026eventstypes.TaskStart{ ContainerID: container.ID, Pid: uint32(p.Pid()), }) default: s.send(\u0026eventstypes.TaskExecStarted{ ContainerID: container.ID, ExecID: r.ExecID, Pid: uint32(p.Pid()), }) } s.eventSendMu.Unlock() return \u0026taskAPI.StartResponse{ Pid: uint32(p.Pid()), }, nil } // Start a container process func (c *Container) Start(ctx context.Context, r *task.StartRequest) (process.Process, error) { p, err := c.Process(r.ExecID) if err != nil { return nil, err } // if err := p.Start(ctx); err != nil { return nil, err } if c.Cgroup() == nil \u0026\u0026 p.Pid() \u003e 0 { var cg interface{} if cgroups.Mode() == cgroups.Unified { g, err := cgroupsv2.PidGroupPath(p.Pid()) if err != nil { logrus.WithError(err).Errorf(\"loading cgroup2 for %d\", p.Pid()) } cg, err = cgroupsv2.LoadManager(\"/sys/fs/cgroup\", g) if err != nil { logrus.WithError(err).Errorf(\"loading cgroup2 for %d\", p.Pid()) } } else { cg, err = cgroups.Load(cgroups.V1, cgroups.PidPath(p.Pid())) if err != nil { logrus.WithError(err).Errorf(\"loading cgroup for %d\", p.Pid()) } } c.cgroup = cg } return p, nil } // Start the init process func (p *Init) Start(ctx context.Context) error { p.mu.Lock() defer p.mu.Unlock() // return p.initState.Start(ctx) } func (s *createdState) Start(ctx context.Context) error { // if err := s.p.start(ctx); err != nil { return err } return s.transition(\"running\") } func (p *Init) start(ctx context.Context) error { // err := p.runtime.Start(ctx, p.id) return p.runtimeError(err, \"OCI runtime start failed\") } // Start will start an already created container func (r *Runc) Start(context context.Context, id string) error { // return r.runOrError(r.command(context, \"start\", id)) } // runOrError will run the provided command. If an error is // encountered and neither Stdout or Stderr was set the error and the // stderr of the command will be returned in the format of \u003cerror\u003e: // \u003cstderr\u003e func (r *Runc) runOrError(cmd *exec.Cmd) error { if cmd.Stdout != nil || cmd.Stderr != nil { ec, err := Monitor.Start(cmd) if err != nil { return err } status, err := Monitor.Wait(cmd, ec) if err == nil \u0026\u0026 status != 0 { err = fmt.Errorf(\"%s did not terminate successfully: %w\", cmd.Args[0], \u0026ExitError{status}) } return er","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:7:1","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"[client] task.Kill() // kill the process and get the exit status if err := task.Kill(ctx, syscall.SIGTERM); err != nil { return err } ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:8:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"[containerd] (l *local) Kill() func (l *local) Kill(ctx context.Context, r *api.KillRequest, _ ...grpc.CallOption) (*ptypes.Empty, error) { t, err := l.getTask(ctx, r.ContainerID) if err != nil { return nil, err } p := runtime.Process(t) if r.ExecID != \"\" { if p, err = t.Process(ctx, r.ExecID); err != nil { return nil, errdefs.ToGRPC(err) } } // if err := p.Kill(ctx, r.Signal, r.All); err != nil { return nil, errdefs.ToGRPC(err) } return empty, nil } func (s *shimTask) Kill(ctx context.Context, signal uint32, all bool) error { // if _, err := s.task.Kill(ctx, \u0026task.KillRequest{ ID: s.ID(), Signal: signal, All: all, }); err != nil { return errdefs.FromGRPC(err) } return nil } [containerd-shim-runc-v2] s.task.Kill() // Kill a process with the provided signal func (s *service) Kill(ctx context.Context, r *taskAPI.KillRequest) (*ptypes.Empty, error) { container, err := s.getContainer(r.ID) if err != nil { return nil, err } // if err := container.Kill(ctx, r); err != nil { return nil, errdefs.ToGRPC(err) } return empty, nil } // Kill a process func (c *Container) Kill(ctx context.Context, r *task.KillRequest) error { p, err := c.Process(r.ExecID) if err != nil { return err } // return p.Kill(ctx, r.Signal, r.All) } // Kill the init process func (p *Init) Kill(ctx context.Context, signal uint32, all bool) error { p.mu.Lock() defer p.mu.Unlock() // return p.initState.Kill(ctx, signal, all) } func (s *runningState) Kill(ctx context.Context, sig uint32, all bool) error { // return s.p.kill(ctx, sig, all) } func (p *Init) kill(ctx context.Context, signal uint32, all bool) error { // err := p.runtime.Kill(ctx, p.id, int(signal), \u0026runc.KillOpts{ All: all, }) return checkKillError(err) } // Kill sends the specified signal to the container func (r *Runc) Kill(context context.Context, id string, sig int, opts *KillOpts) error { args := []string{ \"kill\", } if opts != nil { args = append(args, opts.args()...) } // return r.runOrError(r.command(context, append(args, id, strconv.Itoa(sig))...)) } // runOrError will run the provided command. If an error is // encountered and neither Stdout or Stderr was set the error and the // stderr of the command will be returned in the format of \u003cerror\u003e: // \u003cstderr\u003e func (r *Runc) runOrError(cmd *exec.Cmd) error { if cmd.Stdout != nil || cmd.Stderr != nil { ec, err := Monitor.Start(cmd) if err != nil { return err } status, err := Monitor.Wait(cmd, ec) if err == nil \u0026\u0026 status != 0 { err = fmt.Errorf(\"%s did not terminate successfully: %w\", cmd.Args[0], \u0026ExitError{status}) } return err } // data, err := cmdOutput(cmd, true, nil) defer putBuf(data) if err != nil { return fmt.Errorf(\"%s: %s\", err, data.String()) } return nil } // callers of cmdOutput are expected to call putBuf on the returned Buffer // to ensure it is released back to the shared pool after use. func cmdOutput(cmd *exec.Cmd, combined bool, started chan\u003c- int) (*bytes.Buffer, error) { b := getBuf() cmd.Stdout = b if combined { cmd.Stderr = b } // ec, err := Monitor.Start(cmd) if err != nil { return nil, err } if started != nil { started \u003c- cmd.Process.Pid } status, err := Monitor.Wait(cmd, ec) if err == nil \u0026\u0026 status != 0 { err = fmt.Errorf(\"%s did not terminate successfully: %w\", cmd.Args[0], \u0026ExitError{status}) } return b, err } // Start starts the command a registers the process with the reaper func (m *Monitor) Start(c *exec.Cmd) (chan runc.Exit, error) { ec := m.Subscribe() if err := c.Start(); err != nil { m.Unsubscribe(ec) return nil, err } return ec, nil } 同样的，在 containerd-shim-runc-v2中套了很多层调用，最终还是回到了 (m *Monitor) Start() 查看此时的cmd参数： 发送了 runc kill redis-server 15 命令。 执行完成后，容器状态如下： ➜ ~ n ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES redis-server docker.io/library/redis:5.0.9 \"docker-entrypoint.s…\" 50 minutes ago Exited (0) About a minute ago ➜ ~ ➜ ~ ➜ ~ runc list ID PID STATUS BUNDLE CREATED OWNER redis-server 0 stopped /run/containerd/io.containerd.runtime.v2.task/default/redis-server 2022-11-03T03:04:04.47687884Z root ➜ ~ ➜ ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:8:1","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"defer task.Delete() ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:9:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"defer container.Delete() ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:10:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"总结 本文通过一个简单的例子，忽略了较多细节，了解一个容器在containerd中的主要启动过程。 ","date":"2022-10-30","objectID":"/2022-10-30-containerd-1/:11:0","tags":["containerd","containerd-shim"],"title":"Containerd解析(1)","uri":"/2022-10-30-containerd-1/"},{"categories":null,"content":"1 配置 参考：https://hugoloveit.com/zh-cn/posts/ ","date":"2022-10-29","objectID":"/2022-10-29-my-first-post/:1:0","tags":["test"],"title":"My First Post","uri":"/2022-10-29-my-first-post/"},{"categories":null,"content":"2 图片 ","date":"2022-10-29","objectID":"/2022-10-29-my-first-post/:2:0","tags":["test"],"title":"My First Post","uri":"/2022-10-29-my-first-post/"},{"categories":null,"content":"上传配置 typora配置： typora setting 图片插入： # 使用typora直接拖拽即可 ![image-20221030223715217](https://raw.githubusercontent.com/yzxiu/images/blog/2022-10/20221030-223715.png \"typora setting\") picgo-core插件： # https://connor-sun.github.io/posts/38835.html picgo install super-prefix picgo-core配置： { \"picBed\": { \"github\": { \"repo\": \"*****\", \"token\": \"*****\", \"path\": \"/\", \"customUrl\": \"\", \"branch\": \"blog\" }, \"current\": \"github\", \"uploader\": \"github\" }, \"picgoPlugins\": { \"picgo-plugin-super-prefix\": true }, \"picgo-plugin-super-prefix\": { \"prefixFormat\": \"YYYY-MM/\", \"fileFormat\": \"YYYYMMDD-HHmmss\" } } ","date":"2022-10-29","objectID":"/2022-10-29-my-first-post/:2:1","tags":["test"],"title":"My First Post","uri":"/2022-10-29-my-first-post/"},{"categories":null,"content":"小图展示 小图片如果使用 ![image-20221030223715217](https://raw.githubusercontent.com/yzxiu/images/blog/2022-10/20221030-235308.png \"small image\")的方式插入，会拉伸宽屏，如下： small image 可以改用 \u003cimg\u003e 的方式 ，并使用 {{\u003c style \"text-align:center;\" \u003e}} 控制位置，如下： {{\u003c style \"text-align:center;\" \u003e}} \u003cimg src=\"https://raw.githubusercontent.com/yzxiu/images/blog/2022-10/20221030-235308.png\" style=\"zoom: 80%;\" \u003e {{\u003c /style \u003e}} 呈现的效果如下： 图文混排，使用style=\"zoom: 20%;\"控制大小，如下： 图文混排\u003cimg src=\"https://raw.githubusercontent.com/yzxiu/images/blog/2022-10/20221030-235308.png\" style=\"zoom: 10%;\" /\u003e图文混排 图文混排\u003cimg src=\"https://raw.githubusercontent.com/yzxiu/images/blog/2022-10/20221030-235308.png\" style=\"zoom: 20%;\" /\u003e图文混排 图文混排\u003cimg src=\"https://raw.githubusercontent.com/yzxiu/images/blog/2022-10/20221030-235308.png\" style=\"zoom: 30%;\" /\u003e图文混排 呈现的效果如下： 图文混排图文混排 图文混排图文混排 图文混排图文混排 ","date":"2022-10-29","objectID":"/2022-10-29-my-first-post/:2:2","tags":["test"],"title":"My First Post","uri":"/2022-10-29-my-first-post/"},{"categories":null,"content":"3 代码 package main import \"fmt\" func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } func main() { fmt.Println(split(17)) } ","date":"2022-10-29","objectID":"/2022-10-29-my-first-post/:3:0","tags":["test"],"title":"My First Post","uri":"/2022-10-29-my-first-post/"},{"categories":null,"content":"4 横幅 {{\u003c admonition \u003e}} 一个 **注意** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition abstract \u003e}} 一个 **摘要** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition info \u003e}} 一个 **信息** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition tip \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition success \u003e}} 一个 **成功** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition question \u003e}} 一个 **问题** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition warning \u003e}} 一个 **警告** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition failure \u003e}} 一个 **失败** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition danger \u003e}} 一个 **危险** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition bug \u003e}} 一个 **Bug** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition example \u003e}} 一个 **示例** 横幅 {{\u003c /admonition \u003e}} {{\u003c admonition quote \u003e}} 一个 **引用** 横幅 {{\u003c /admonition \u003e}} 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 ","date":"2022-10-29","objectID":"/2022-10-29-my-first-post/:4:0","tags":["test"],"title":"My First Post","uri":"/2022-10-29-my-first-post/"}]